var documenterSearchIndex = {"docs":
[{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ChainModel","category":"page"},{"location":"api/#ChainModels.ChainModel","page":"API","title":"ChainModels.ChainModel","text":"ChainModel{T,L} <: DiscreteMultivariateDistribution\n\nA type to represent a discrete multivariate probability distribution factorized on a one-dimensional chain of length L.\n\nFIELDS\n\nf :: Vector{Matrix{T}} contains the factors\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"accumulate_left\naccumulate_right\naccumulate_middle\naccumulate_left!\naccumulate_right!\naccumulate_middle!\n\nnstates\nlength\nevaluate\nlogevaluate\nnormalization\nlognormalization\nnormalize!\nnormalize\nmarginals\nneighbor_marginals\npair_marginals\nloglikelihood_gradient\nloglikelihood_gradient!","category":"page"},{"location":"api/#ChainModels.accumulate_left","page":"API","title":"ChainModels.accumulate_left","text":"accumulate_left(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the left partial normalization for the matrices in f\n\nl_i(x_i+1) = logsumlimits_x_1ldotsx_iprodlimits_j=1^i e^f_j(x_jx_j+1)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.accumulate_right","page":"API","title":"ChainModels.accumulate_right","text":"accumulate_right(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the right partial normalization for the matrices in f\n\nr_i(x_i-1) = logsumlimits_x_ildotsx_Lprodlimits_j=i-1^L e^f_j(x_jx_j+1)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.accumulate_middle","page":"API","title":"ChainModels.accumulate_middle","text":"accumulate_middle(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the middle partial normalization for the matrices in f\n\nm_ij(x_ix_j) = logsumlimits_x_i+1ldotsx_j-1prodlimits_k=i^j-1 e^f_k(x_kx_k+1)\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.accumulate_left!","page":"API","title":"ChainModels.accumulate_left!","text":"accumulate_left!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_left\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.accumulate_right!","page":"API","title":"ChainModels.accumulate_right!","text":"accumulate_right!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_right\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.accumulate_middle!","page":"API","title":"ChainModels.accumulate_middle!","text":"accumulate_middle!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_middle\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.nstates","page":"API","title":"ChainModels.nstates","text":"nstates(f::Vector{Matrix{T}}) where {T<:Real}\n\nReturns an iterator with the number of values each variable can take.\n\n\n\n\n\nnstates(chain::ChainModel{T,L})\n\nReturns a NTuple{L,Int} with the number of values each variable can take.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API","title":"Base.length","text":"Base.length(::ChainModel{T,L})\n\nReturns L, the number of variables\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.evaluate","page":"API","title":"ChainModels.evaluate","text":"evaluate(chain::ChainModel, x)\n\nEvaluate the (possibly unnormalized) model at x\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.logevaluate","page":"API","title":"ChainModels.logevaluate","text":"logevaluate(chain::ChainModel, x)\n\nConceptually equivalent to log(evaluate(chain, x)), less prone to numerical issues\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.normalization","page":"API","title":"ChainModels.normalization","text":"normalization(chain::ChainModel; l = accumulate_left(chain))\n\nCompute the normalization\n\nbeginaligned\nZ = sumlimits_x_1ldotsx_Lprodlimits_i=1^L-1 e^f_i(x_ix_i+1)\n  = sumlimits_x_L e^l_L-1(x_L)\nendaligned\n\nOptionally, pass the pre-computed left partial normalization\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.lognormalization","page":"API","title":"ChainModels.lognormalization","text":"lognormalization(chain::ChainModel; l = accumulate_left(chain))\n\nConceptually equivalent to log(normalization(chain)), less prone to numerical issues\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.normalize!","page":"API","title":"LinearAlgebra.normalize!","text":"normalize!(chain::ChainModel; logZ = lognormalization(chain))\n\nDivide each factor by Z^1L so that the normalization becomes 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.normalize","page":"API","title":"LinearAlgebra.normalize","text":"normalize(chain::ChainModel; logZ = lognormalization(chain))\n\nReturn a new ChainModel equivalent to chain but rescaled so that normalization equal to 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.marginals","page":"API","title":"ChainModels.marginals","text":"marginals(chain::ChainModel; l = accumulate_left(chain), r = accumulate_right(chain))\n\nCompute single-variable marginals\n\nbeginaligned\np(x_i=x) = sum_x_1 x_2 ldots x_L p(x_1 x_2 ldots x_L) delta(x_ix)\n= frac1Z e^l_i-1(x)+r_i+1(x)\nendaligned\n\nOptionally, pass the pre-computed left and right partial normalization\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.neighbor_marginals","page":"API","title":"ChainModels.neighbor_marginals","text":"neighbor_marginals(chain::ChainModel; l = accumulate_left(chain), r = accumulate_right(chain))\n\nCompute nearest-neighbor marginals\n\nbeginaligned\np(x_i=xx_i+1=x) = sum_x_1 x_2 ldots x_L p(x_1 x_2 ldots x_L) delta(x_ix) delta(x_i+1x)\n= frac1Z e^l_i-1(x) + f_i(xx) + r_i+2(x)\nendaligned\n\nOptionally, pass the pre-computed left and right partial normalization\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.pair_marginals","page":"API","title":"ChainModels.pair_marginals","text":"neighbor_marginals(chain::ChainModel; l = accumulate_left(chain), r = accumulate_right(chain), m = accumulate_middle(chain))\n\nCompute pair marginals\n\nbeginaligned\np(x_i=xx_j=x) = sum_x_1 x_2 ldots x_L p(x_1 x_2 ldots x_L) delta(x_ix) delta(x_jx)\n=  frac1Z e^l_i-1(x) + m_ij(xx) + r_j+1(x)\nendaligned\n\nOptionally, pass the pre-computed left, right and middle partial normalization\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.loglikelihood_gradient","page":"API","title":"ChainModels.loglikelihood_gradient","text":"loglikelihood_gradient(chain::ChainModel, x; neigmarg = neighbor_marginals(chain))\n\nCompute the gradient of the loglikelihood mathcalL(boldsymbolx) of samples x^(mu)_mu=1ldotsM with respect to the functions chain.f\n\nfracdmathcalL(boldsymbolx)d f_i(y_iy_i+1) = sum_mu=1^M delta(y_ix_i^(mu))delta(y_i+1x_i+1^(mu)) - M p(y_iy_i+1) \n\nOptionally pass pre-computed neighbor marginals\n\n\n\n\n\n","category":"function"},{"location":"api/#ChainModels.loglikelihood_gradient!","page":"API","title":"ChainModels.loglikelihood_gradient!","text":"loglikelihood_gradient!(df, chain::ChainModel, x; neigmarg = neighbor_marginals(chain)\n\nIn-place version of loglikelihood_gradient\n\n\n\n\n\n","category":"function"},{"location":"#ChainModels.jl","page":"Home","title":"ChainModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides utilities to deal with multivariate functions factorized over a one-dimensional chain, i.e. where each variable x_i interacts only with x_i-1 and x_i+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x_1ldotsx_L) = e^f_1(x_1x_2) e^f_2(x_2x_3) cdots e^f_L-1(x_L-1x_L) = prod_i=1^L-1 e^f_i(x_ix_i+1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x_i in mathcalX_i=12ldotsq_i and f_i  mathcalX_i times mathcalX_i+1 to mathbbR. Once properly normalized, these give probability distributions","category":"page"},{"location":"","page":"Home","title":"Home","text":"p(x_1ldotsx_L) = frac1Zprod_i=1^L-1 e^f_i(x_ix_i+1) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"with Z = sumlimits_x_1ldotsx_Lprodlimits_i=1^L-1 e^f_i(x_ix_i+1) the normalization constant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In other words, a probability distribution is a chain model if its factor graph is a simple path:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Chain Factor Graph)","category":"page"},{"location":"#Provided-functionalities","page":"Home","title":"Provided functionalities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a chain of length L with variables taking one of q values, the following can be performed efficiently:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Operation Cost\nCompute normalization Z mathcal O (Lq^2)\nCompute marginals p(x_i) mathcal O (Lq^2)\nCompute neighbor marginals p(x_ix_i+1) mathcal O (Lq^2)\nCompute pair marginals p(x_ix_j) mathcal O (L^2q^2)\nDraw a sample from p mathcal O (Lq^2)\nCompute the entropy S[p]=-\\sum_xp(x)\\log p(x) $ mathcal O (Lq^2)\nCompute the log-likelihood log L=sumlimits_mu=1^Nlog p(x^(mu)) of N samples mathcal O (Lq^2 + NL)\nCompute the gradient of the log-likelihood fracdlog Ld f_i(x_ix_i+1) mathcal O (Lq^2 + NLq^2)","category":"page"},{"location":"#Examples-of-chain-models","page":"Home","title":"Examples of chain models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Markov Chains\nOne-dimensional Ising models","category":"page"},{"location":"#Efficient-operations","page":"Home","title":"Efficient operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The efficiency of the operations mentioned above relies on some strategic pre-computations. For examples, partial normalizations from the left and from the right (l and r, respectively)","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nl_i(x_i+1) = logsumlimits_x_1ldotsx_iprodlimits_j=1^i e^f_j(x_jx_j+1)\nr_i(x_i-1) = logsumlimits_x_ildotsx_Lprodlimits_j=i-1^L e^f_j(x_jx_j+1)\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"can be used to compute normalization, single-variable and nearest-neighbor marginals","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nZ = sumlimits_x_i e^l_i-1(x_i)+r_i+1(x_i)quadforall i\np(x_i) = frac1Z e^l_i-1(x_i)+r_i+1(x_i)\np(x_ix_i+1) = frac1Z e^l_i-1(x_i) + f_i(x_ix_i+1) + r_i+2(x_i+1)\nendaligned","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The exponential parametrization is favorable because it puts no constraint on the values taken by the f_i's, which can be positive or negative. One might as well parametrize directly as f(x)=prodlimits_i=1^L-1 g_i(x_ix_i+1) with g_i(x_ix_i+1)=e^f_i(x_ix_i+1), but must always ensure g_i ge 0.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install with","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"https://github.com/stecrotti/ChainModels.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create a ChainModel and compute some stuff","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ChainModels\n\nL = 100\nq = fill(20, L)\nf = [randn(q[i], q[i+1]) for i in 1:L-1]\np = ChainModel(f)\n\nZ = normalization(p)\nmarg = marginals(p)\nneigmarg = neighbor_marginals(p)\npairmarg = pair_marginals(p)\nS = entropy(p)\nx = rand(p, 500)\nlogL = loglikelihood(p, x)","category":"page"}]
}
