var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [ChainModels]\nOrder = [:type, :function]","category":"page"},{"location":"api/#ChainModels.ChainModel","page":"API","title":"ChainModels.ChainModel","text":"ChainModel{T,L} <: DiscreteMultivariateDistribution\n\nA type to represent a discrete multivariate probability distribution factorized on a one-dimensional chain of length L.\n\nFIELDS\n\nf :: Vector{Matrix{T}} contains the factors\n\n\n\n\n\n","category":"type"},{"location":"api/#ChainModels.ChainModel-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Vector{T}, 1}}} where T<:Real","page":"API","title":"ChainModels.ChainModel","text":"ChainModel(f::Vector{Matrix{T}}, h::Vector{Vector{T}})\n\nConstruct a ChainModel from neighboring interactions f and single-site biases h.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Union{Tuple{ChainModel{T, L}}, Tuple{L}, Tuple{T}} where {T, L}","page":"API","title":"Base.length","text":"Base.length(::ChainModel{T,L})\n\nReturns L, the number of variables\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_left!-Union{Tuple{T}, Tuple{Any, Array{Matrix{T}, 1}}} where T<:Real","page":"API","title":"ChainModels.accumulate_left!","text":"accumulate_left!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_left\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_left-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"ChainModels.accumulate_left","text":"accumulate_left(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the left partial normalization for the matrices in f\n\nl_i(x_i+1) = logsumlimits_x_1ldotsx_iprodlimits_j=1^i e^f_j(x_jx_j+1)\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_middle!-Union{Tuple{T}, Tuple{Any, Array{Matrix{T}, 1}}} where T<:Real","page":"API","title":"ChainModels.accumulate_middle!","text":"accumulate_middle!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_middle\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_middle-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"ChainModels.accumulate_middle","text":"accumulate_middle(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the middle partial normalization for the matrices in f\n\nm_ij(x_ix_j) = logsumlimits_x_i+1ldotsx_j-1prodlimits_k=i^j-1 e^f_k(x_kx_k+1)\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_right!-Union{Tuple{T}, Tuple{Any, Array{Matrix{T}, 1}}} where T<:Real","page":"API","title":"ChainModels.accumulate_right!","text":"accumulate_right!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_right\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_right-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"ChainModels.accumulate_right","text":"accumulate_right(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the right partial normalization for the matrices in f\n\nr_i(x_i-1) = logsumlimits_x_ildotsx_Lprodlimits_j=i-1^L e^f_j(x_jx_j+1)\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.energy-Tuple{ChainModel}","page":"API","title":"ChainModels.energy","text":"energy(chain::ChainModel; nmarg = neighbor_marginals(chain))\n\nCompute the \"energy\"\n\nbeginaligned\nE = mathbbE sum_x_1 x_2 ldots x_L left -sumlimits_i=1^L-1f_i(x_ix_i+1) right p(x_1 x_2 ldots x_L)\n=  -sumlimits_i=1^L-1 sum_xx f_i(xx) p(x_i=xx_i+1=x)\nendaligned\n\nOptionally, pass the pre-computed neighbor marginals\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.evaluate-Tuple{ChainModel, Any}","page":"API","title":"ChainModels.evaluate","text":"evaluate(chain::ChainModel, x)\n\nEvaluate the (possibly unnormalized) model at x\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.logevaluate-Tuple{ChainModel, Any}","page":"API","title":"ChainModels.logevaluate","text":"logevaluate(chain::ChainModel, x)\n\nConceptually equivalent to log(evaluate(chain, x)), less prone to numerical issues\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.lognormalization-Tuple{ChainModel}","page":"API","title":"ChainModels.lognormalization","text":"lognormalization(chain::ChainModel; l = accumulate_left(chain))\n\nConceptually equivalent to log(normalization(chain)), less prone to numerical issues\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.marginals-Tuple{ChainModel}","page":"API","title":"ChainModels.marginals","text":"marginals(chain::ChainModel; l = accumulate_left(chain), r = accumulate_right(chain))\n\nCompute single-variable marginals\n\nbeginaligned\np(x_i=x) = sum_x_1 x_2 ldots x_L p(x_1 x_2 ldots x_L) delta(x_ix)\n= frac1Z e^l_i-1(x)+r_i+1(x)\nendaligned\n\nOptionally, pass the pre-computed left and right partial normalization\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.neighbor_marginals-Tuple{ChainModel}","page":"API","title":"ChainModels.neighbor_marginals","text":"neighbor_marginals(chain::ChainModel; l = accumulate_left(chain), r = accumulate_right(chain))\n\nCompute nearest-neighbor marginals\n\nbeginaligned\np(x_i=xx_i+1=x) = sum_x_1 x_2 ldots x_L p(x_1 x_2 ldots x_L) delta(x_ix) delta(x_i+1x)\n= frac1Z e^l_i-1(x) + f_i(xx) + r_i+2(x)\nendaligned\n\nOptionally, pass the pre-computed left and right partial normalization\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.normalization-Tuple{ChainModel}","page":"API","title":"ChainModels.normalization","text":"normalization(chain::ChainModel; l = accumulate_left(chain))\n\nCompute the normalization\n\nbeginaligned\nZ = sumlimits_x_1ldotsx_Lprodlimits_i=1^L-1 e^f_i(x_ix_i+1)\n  = sumlimits_x_L e^l_L-1(x_L)\nendaligned\n\nOptionally, pass the pre-computed left partial normalization\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.nstates-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"ChainModels.nstates","text":"nstates(f::Vector{Matrix{T}}) where {T<:Real}\n\nReturns an iterator with the number of values each variable can take.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.nstates-Union{Tuple{ChainModel{T, L}}, Tuple{L}, Tuple{T}} where {T, L}","page":"API","title":"ChainModels.nstates","text":"nstates(chain::ChainModel{T,L})\n\nReturns a NTuple{L,Int} with the number of values each variable can take.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.pair_marginals-Union{Tuple{ChainModel{T}}, Tuple{T}} where T","page":"API","title":"ChainModels.pair_marginals","text":"pair_marginals(chain::ChainModel; l = accumulate_left(chain), r = accumulate_right(chain), m = accumulate_middle(chain))\n\nCompute pair marginals\n\nbeginaligned\np(x_i=xx_j=x) = sum_x_1 x_2 ldots x_L p(x_1 x_2 ldots x_L) delta(x_ix) delta(x_jx)\n=  frac1Z e^l_i-1(x) + m_ij(xx) + r_j+1(x)\nendaligned\n\nOptionally, pass the pre-computed left, right and middle partial normalization\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.rand_chain_model-Tuple{Random.AbstractRNG, Integer, Integer}","page":"API","title":"ChainModels.rand_chain_model","text":"rand_chain_model([rng], L::Integer, q::Integer)\n\nReturn a  ChainModel of length L and q states for each variable, with random entries\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.normalize!-Tuple{ChainModel}","page":"API","title":"LinearAlgebra.normalize!","text":"normalize!(chain::ChainModel; logZ = lognormalization(chain))\n\nDivide each factor by Z^1L so that the normalization becomes 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.normalize-Tuple{ChainModel}","page":"API","title":"LinearAlgebra.normalize","text":"normalize(chain::ChainModel; logZ = lognormalization(chain))\n\nReturn a new ChainModel equivalent to chain but rescaled so that normalization equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"#ChainModels.jl","page":"Home","title":"ChainModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides utilities to deal with multivariate functions factorized over a one-dimensional chain, i.e. where each variable x_i interacts only with x_i-1 and x_i+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x_1ldotsx_L) = e^f_1(x_1x_2) e^f_2(x_2x_3) cdots e^f_L-1(x_L-1x_L) = prod_i=1^L-1 e^f_i(x_ix_i+1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x_i in mathcalX_i=12ldotsq_i and f_i  mathcalX_i times mathcalX_i+1 to mathbbR. Once properly normalized, these give probability distributions","category":"page"},{"location":"","page":"Home","title":"Home","text":"p(x_1ldotsx_L) = frac1Zprod_i=1^L-1 e^f_i(x_ix_i+1) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"with Z = sumlimits_x_1ldotsx_Lprodlimits_i=1^L-1 e^f_i(x_ix_i+1) the normalization constant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In other words, a probability distribution is a chain model if its factor graph is a simple path:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Chain Factor Graph)","category":"page"},{"location":"#Provided-functionalities","page":"Home","title":"Provided functionalities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a chain of length L with variables taking one of q values, the following can be performed efficiently:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Operation Cost\nCompute normalization Z mathcal O (Lq^2)\nCompute marginals p(x_i) mathcal O (Lq^2)\nCompute neighbor marginals p(x_ix_i+1) mathcal O (Lq^2)\nCompute pair marginals p(x_ix_j) mathcal O (L^2q^2)\nDraw a sample from p mathcal O (Lq^2)\nCompute the entropy S[p]=-\\sum_xp(x)\\log p(x) $ mathcal O (Lq^2)","category":"page"},{"location":"#Examples-of-chain-models","page":"Home","title":"Examples of chain models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Markov Chains\nOne-dimensional Ising models","category":"page"},{"location":"#Efficient-operations","page":"Home","title":"Efficient operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The efficiency of the operations mentioned above relies on some strategic pre-computations. For example, partial normalizations from the left and from the right (l and r, respectively)","category":"page"},{"location":"","page":"Home","title":"Home","text":"begineqnarray\nl_i(x_i+1) = logsumlimits_x_1ldotsx_iprodlimits_j=1^i e^f_j(x_jx_j+1)\nr_i(x_i-1) = logsumlimits_x_ildotsx_Lprodlimits_j=i-1^L e^f_j(x_jx_j+1)\nendeqnarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"can be used to compute normalization, single-variable and nearest-neighbor marginals","category":"page"},{"location":"","page":"Home","title":"Home","text":"begineqnarray\nZ = sumlimits_x_i e^l_i-1(x_i)+r_i+1(x_i)quadforall i\np(x_i) = frac1Z e^l_i-1(x_i)+r_i+1(x_i)\np(x_ix_i+1) = frac1Z e^l_i-1(x_i) + f_i(x_ix_i+1) + r_i+2(x_i+1)\nendeqnarray","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The exponential parametrization is favorable because it puts no constraint on the values taken by the f_i's, which can be positive or negative. One might as well parametrize directly as f(x)=prodlimits_i=1^L-1 g_i(x_ix_i+1) with g_i(x_ix_i+1)=e^f_i(x_ix_i+1), but must always ensure g_i ge 0.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install with","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"https://github.com/stecrotti/ChainModels.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create a ChainModel and compute some stuff","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ChainModels\n\nL = 100\nq = fill(20, L)\nf = [randn(q[i], q[i+1]) for i in 1:L-1]\np = ChainModel(f)\n\nZ = normalization(p)\nmarg = marginals(p)\nneigmarg = neighbor_marginals(p)\npairmarg = pair_marginals(p)\nS = entropy(p)\nx = rand(p, 500)\nl = loglikelihood(p, x)","category":"page"}]
}
