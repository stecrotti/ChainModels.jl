var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [ChainModels]\nOrder = [:type, :function]","category":"page"},{"location":"api/#ChainModels.KChainModel","page":"API","title":"ChainModels.KChainModel","text":"KChainModel{T,L} <: DiscreteMultivariateDistribution\n\nA type to represent a discrete multivariate probability distribution factorized on a one-dimensional chain of length L.\n\nFIELDS\n\nf a vector containing the factors as arrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ChainModels.accumulate_left!-Union{Tuple{K}, Tuple{T}, Tuple{Any, AbstractVector{<:AbstractArray{T, K}}}} where {T<:Real, K}","page":"API","title":"ChainModels.accumulate_left!","text":"accumulate_left!(l, f::AbstractVector{<:AbstractArray{<:Real,K}}) where {K}\n\nIn-place version of accumulate_left\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_left-Union{Tuple{AbstractVector{<:AbstractArray{T, K}}}, Tuple{K}, Tuple{T}} where {T, K}","page":"API","title":"ChainModels.accumulate_left","text":"accumulate_left(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the left partial normalization for the matrices in f\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_middle!-Union{Tuple{T}, Tuple{Any, Array{Matrix{T}, 1}}} where T<:Real","page":"API","title":"ChainModels.accumulate_middle!","text":"accumulate_middle!(l, f::Vector{Matrix{T}}) where {T<:Real}\n\nIn-place version of accumulate_middle\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_middle-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"ChainModels.accumulate_middle","text":"accumulate_middle(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the middle partial normalization for the matrices in f\n\nm_ij(x_ix_j) = logsumlimits_x_i+1ldotsx_j-1prodlimits_k=i^j-1 e^f_k(x_kx_k+1)\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_right!-Union{Tuple{K}, Tuple{T}, Tuple{Any, AbstractVector{<:AbstractArray{T, K}}}} where {T<:Real, K}","page":"API","title":"ChainModels.accumulate_right!","text":"accumulate_right!(l, f::AbstractVector{<:AbstractArray{<:Real,K}}) where {K}\n\nIn-place version of accumulate_right\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.accumulate_right-Union{Tuple{AbstractVector{<:AbstractArray{T, K}}}, Tuple{K}, Tuple{T}} where {T, K}","page":"API","title":"ChainModels.accumulate_right","text":"accumulate_right(f::Vector{Matrix{T}}) where {T<:Real}\n\nCompute the right partial normalization for the matrices in f\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.evaluate-Tuple{KChainModel, Any}","page":"API","title":"ChainModels.evaluate","text":"evaluate(chain::ChainModel, x)\n\nEvaluate the (possibly unnormalized) model at x\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.lognormalization-Tuple{KChainModel}","page":"API","title":"ChainModels.lognormalization","text":"lognormalization(chain::ChainModel; l = accumulate_left(chain))\n\nConceptually equivalent to log(normalization(chain)), less prone to numerical issues\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.nstates-Union{Tuple{AbstractVector{<:AbstractArray{T, K}}}, Tuple{K}, Tuple{T}} where {T<:Real, K}","page":"API","title":"ChainModels.nstates","text":"nstates(f::AbstractVector{<:AbstractArray{<:Real}})\n\nReturns an iterator with the number of values each variable can take.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChainModels.rand_kchain_model-Tuple{Random.AbstractRNG, Integer, Integer, Integer}","page":"API","title":"ChainModels.rand_kchain_model","text":"rand_kchain_model([rng], K::Integer, L::Integer, q::Integer)\n\nReturn a  KChainModel of length L and q states for each variable, with random entries\n\n\n\n\n\n","category":"method"},{"location":"#ChainModels.jl","page":"Home","title":"ChainModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides utilities to deal with multivariate functions factorized over a one-dimensional chain, i.e. where each variable x_i interacts only with x_i-1 and x_i+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x_1ldotsx_L) = e^f_1(x_1x_2) e^f_2(x_2x_3) cdots e^f_L-1(x_L-1x_L) = prod_i=1^L-1 e^f_i(x_ix_i+1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where x_i in mathcalX_i=12ldotsq_i and f_i  mathcalX_i times mathcalX_i+1 to mathbbR. Once properly normalized, these give probability distributions","category":"page"},{"location":"","page":"Home","title":"Home","text":"p(x_1ldotsx_L) = frac1Zprod_i=1^L-1 e^f_i(x_ix_i+1) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"with Z = sumlimits_x_1ldotsx_Lprodlimits_i=1^L-1 e^f_i(x_ix_i+1) the normalization constant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In other words, a probability distribution is a chain model if its factor graph is a simple path:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Chain Factor Graph)","category":"page"},{"location":"#Provided-functionalities","page":"Home","title":"Provided functionalities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a chain of length L with variables taking one of q values, the following can be performed efficiently:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Operation Cost\nCompute normalization Z mathcal O (Lq^2)\nCompute marginals p(x_i) mathcal O (Lq^2)\nCompute neighbor marginals p(x_ix_i+1) mathcal O (Lq^2)\nCompute pair marginals p(x_ix_j) mathcal O (L^2q^2)\nDraw a sample from p mathcal O (Lq^2)\nCompute the entropy S[p]=-\\sum_xp(x)\\log p(x) $ mathcal O (Lq^2)","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install with","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"https://github.com/stecrotti/ChainModels.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create a ChainModel and compute some stuff","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ChainModels\n\nL = 100\nq = fill(20, L)\nf = [randn(q[i], q[i+1]) for i in 1:L-1]\np = ChainModel(f)\n\nZ = normalization(p)\nmarg = marginals(p)\nneigmarg = neighbor_marginals(p)\npairmarg = pair_marginals(p)\nS = entropy(p)\nx = rand(p, 500)\nl = loglikelihood(p, x)","category":"page"},{"location":"#Examples-of-chain-models","page":"Home","title":"Examples of chain models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Markov Chains\nOne-dimensional Ising models","category":"page"},{"location":"#Efficient-operations","page":"Home","title":"Efficient operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The efficiency of the operations mentioned above relies on some strategic pre-computations. For example, partial normalizations from the left and from the right (l and r, respectively)","category":"page"},{"location":"","page":"Home","title":"Home","text":"begineqnarray\nl_i(x_i+1) = logsumlimits_x_1ldotsx_iprodlimits_j=1^i e^f_j(x_jx_j+1)\nr_i(x_i-1) = logsumlimits_x_ildotsx_Lprodlimits_j=i-1^L-1 e^f_j(x_jx_j+1)\nendeqnarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"can be used to compute normalization, single-variable and nearest-neighbor marginals","category":"page"},{"location":"","page":"Home","title":"Home","text":"begineqnarray\nZ = sumlimits_x_i e^l_i-1(x_i)+r_i+1(x_i)quadforall i\np(x_i) = frac1Z e^l_i-1(x_i)+r_i+1(x_i)\np(x_ix_i+1) = frac1Z e^l_i-1(x_i) + f_i(x_ix_i+1) + r_i+2(x_i+1)\nendeqnarray","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The exponential parametrization is favorable because it puts no constraint on the values taken by the f_i's, which can be positive or negative. One might as well parametrize directly as f(x)=prodlimits_i=1^L-1 g_i(x_ix_i+1) with g_i(x_ix_i+1)=e^f_i(x_ix_i+1), but must always ensure g_i ge 0.","category":"page"},{"location":"#K-Chain-Models","page":"Home","title":"K-Chain Models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package supports a more general type of Chain Models where interactions involve not just two neighboring variables but a general number K. The distribution in this case reads","category":"page"},{"location":"","page":"Home","title":"Home","text":"p(x_1ldotsx_L) = frac1Zprod_i=1^L-K+1 e^f_i(x_ix_i+1 ldots x_i+K-1) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A K-Chain Model can be constructed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"chain = KChainModel(fK)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where fK is a vector of length L-K+1 whose i-th element is an array of size q_i q_i+1 ldots q_i+K-1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Special constructors are provided for the special cases K=1, where the chain reduces to a fully factorized model where each variable is independent of the others","category":"page"},{"location":"","page":"Home","title":"Home","text":"chain = FactorizedModel(f1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and K=2, as shown above","category":"page"},{"location":"","page":"Home","title":"Home","text":"chain = ChainModel(f2)","category":"page"}]
}
